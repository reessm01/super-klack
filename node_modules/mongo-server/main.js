"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs-extra-promise");
const EventEmiter = require("events");
const child_process_1 = require("child_process");
class MongoOptions {
    constructor() {
        this.dbpath = path.join(__dirname, 'database');
        this.port = 27017;
        this.host = '127.0.0.1';
        this.bin = path.join(__dirname, './libs/server/mongod');
    }
    set(name, value) {
        if (!this[name])
            throw new Error(`Property with name '${name}' not found`);
        if (typeof this[name] !== typeof value)
            throw new Error(`Invalid data type for '${name}' property. This property needs a type ${typeof this[name]}`);
        if ((name === 'dbpath' || name === 'bin') && typeof value === 'string') {
            let segments = [];
            for (let segment of value.split('/')) {
                segment = segment.replace(/DIR/g, __dirname);
                segment = segment.replace(/CWD/g, process.cwd());
                segment = segment.replace(/\./g, process.cwd());
                segments.push(segment);
            }
            value = path.join(...segments);
        }
        if (name === 'host' && typeof value === 'string') {
            if (!/^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$/.test(value))
                throw new Error(`Invalid 'host' property value. Example: '127.0.0.1'`);
        }
        if (name === 'port' && typeof value === 'number') {
            if (value <= 80 || value > 65535)
                throw new Error(`Invalid 'port' property value. Port value is integer 81-65535 numbers`);
        }
        this[name] = value;
        return value;
    }
    get mongodbString() {
        return `mongodb://${this.host}:${this.port}`;
    }
}
exports.MongoOptions = MongoOptions;
exports.fsDeleteFolder = (folder) => __awaiter(this, void 0, void 0, function* () {
    if (yield fs.existsAsync(folder)) {
        let files = yield fs.readdirAsync(folder);
        for (let file of files) {
            let curPath = path.join(folder, file);
            if ((yield fs.lstatAsync(curPath)).isDirectory()) {
                yield exports.fsDeleteFolder(curPath);
            }
            else {
                yield fs.unlinkAsync(curPath);
            }
        }
        yield fs.rmdirAsync(folder);
    }
});
class MongoServer {
    static run() {
        let that = MongoServer;
        let options = that.options;
        let events = that.evets;
        if (that.process && !that.process.killed) {
            that.process.kill('STOPED_SERVER');
            that.process = null;
        }
        function start() {
            return __awaiter(this, void 0, void 0, function* () {
                if (!(yield fs.existsAsync(options.dbpath))) {
                    yield fs.mkdirAsync(options.dbpath);
                }
                else {
                    let stat = yield fs.lstatAsync(options.dbpath);
                    if (!stat.isDirectory()) {
                        yield fs.unlinkAsync(options.dbpath);
                        yield fs.mkdirAsync(options.dbpath);
                    }
                    else {
                        for (let file of yield fs.readdirAsync(options.dbpath)) {
                            if (file.indexOf('mongod.lock') !== -1)
                                yield fs.unlinkAsync(path.join(options.dbpath, file));
                        }
                        yield exports.fsDeleteFolder(path.join(options.dbpath, 'diagnostic.data'));
                    }
                }
                let argvs = [];
                argvs.push(`--dbpath=${options['dbpath']}`);
                argvs.push(`--port=${options.port}`);
                that.process = child_process_1.spawn(options.bin, argvs);
                return new Promise((resolve, reject) => {
                    that.process.once('close', () => __awaiter(this, void 0, void 0, function* () {
                        let logPath = path.join(process.cwd(), 'startLog.log');
                        let error = new Error(`The database started with an error. ReadMode in ${logPath}`);
                        yield fs.writeFileAsync(logPath, that.logout, 'utf-8');
                        events.emit('error', error);
                        reject(error);
                    }));
                    that.process.stdout.on('data', (data) => {
                        that.logout += data.toString();
                        if (!that._runned) {
                            if (that.logout.indexOf('waiting for connections') !== -1) {
                                that._runned = true;
                                events.emit('ready', options);
                                resolve(options);
                            }
                        }
                    });
                });
            });
        }
        return new Promise((resolve, reject) => {
            start().then(resolve, reject);
        });
    }
    static setOption(name, value) {
        return MongoServer.options.set(name, value);
    }
    static on(...args) {
        MongoServer.evets.on.apply(MongoServer.evets, args);
    }
    static once(...args) {
        MongoServer.evets.once.apply(MongoServer.evets, args);
    }
    static off(name, callback) {
        MongoServer.evets.removeListener(name, callback);
    }
}
MongoServer.evets = new EventEmiter();
MongoServer.options = new MongoOptions();
MongoServer.logout = '';
MongoServer._runned = false;
exports.MongoServer = MongoServer;
